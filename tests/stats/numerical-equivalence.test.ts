/**
 * Numerical equivalence tests for 14 new statistical methods.
 * Compares Carm implementations against R reference values from
 * tests/fixtures/new-methods-ref.json (generated by new-methods-ref.R).
 *
 * Tolerances:
 *   - Statistics/coefficients: 0.01
 *   - P-values: 0.001
 *   - Iterative methods (NB, ordinal): 0.05
 *   - Theta/dispersion: 0.1
 */

import { describe, it, expect } from 'vitest'
import ref from '../fixtures/new-methods-ref.json'

import {
  welchANOVA,
  moodsMedianTest,
  cochranQ,
  ancova,
  twoWayANOVA,
} from '../../src/stats/comparison.js'

import {
  mcnemarsTest,
  binomialTest,
  proportionsZTest,
  cramersVWithCI,
  chiSquareTest,
} from '../../src/stats/frequency.js'

import {
  pointBiserialCorrelation,
} from '../../src/stats/correlation.js'

import {
  quasiPoissonRegression,
  negativeBinomialRegression,
  ordinalLogisticRegression,
} from '../../src/stats/regression.js'

import {
  bootstrapCI,
} from '../../src/stats/bootstrap.js'

// ─── Welch's ANOVA ────────────────────────────────────────────────────────

describe('Welch ANOVA — R equivalence', () => {
  it('matches R oneway.test (equal-variance groups)', () => {
    const d = ref.welchANOVA
    const groups = Object.entries(d.data).map(([label, values]) => ({ label, values }))
    const result = welchANOVA(groups)

    expect(result.statistic).toBeCloseTo(d.statistic, 2)
    expect((result.df as readonly number[])[1]).toBeCloseTo(d.df_den, 1)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
  })

  it('matches R oneway.test (heteroscedastic groups)', () => {
    const d = ref.welchANOVA_hetero
    const groups = Object.entries(d.data).map(([label, values]) => ({ label, values }))
    const result = welchANOVA(groups)

    expect(result.statistic).toBeCloseTo(d.statistic, 2)
    expect((result.df as readonly number[])[1]).toBeCloseTo(d.df_den, 1)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
  })
})

// ─── Mood's Median Test ──────────────────────────────────────────────────

describe("Mood's Median Test — R equivalence", () => {
  it('matches R mood.medtest', () => {
    const d = ref.moodsMedian
    const groups = Object.entries(d.data).map(([label, values]) => ({ label, values }))
    const result = moodsMedianTest(groups)

    expect(result.statistic).toBeCloseTo(d.statistic, 2)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
  })
})

// ─── Cochran's Q Test ───────────────────────────────────────────────────

describe("Cochran's Q Test — R equivalence", () => {
  it('matches R cochran.qtest', () => {
    const d = ref.cochranQ
    // R fixture: dataMatrix is n×k (8 subjects × 3 conditions)
    // Our function expects n×k: subjects × conditions — no transposition needed
    const result = cochranQ(d.dataMatrix)

    expect(result.statistic).toBeCloseTo(d.statistic, 2)
    expect(result.df).toBe(d.df)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
  })
})

// ─── McNemar's Test ─────────────────────────────────────────────────────

describe("McNemar's Test — R equivalence", () => {
  it('matches R mcnemar.test (no correction)', () => {
    const d = ref.mcnemar
    const result = mcnemarsTest(d.b, d.c, false)

    expect(result.statistic).toBeCloseTo(d.noCorrection.statistic, 2)
    expect(result.pValue).toBeCloseTo(d.noCorrection.pValue, 3)
    expect(result.effectSize.value).toBeCloseTo(d.oddsRatio, 2)
  })

  it('matches R mcnemar.test (with correction)', () => {
    const d = ref.mcnemar
    const result = mcnemarsTest(d.b, d.c, true)

    expect(result.statistic).toBeCloseTo(d.withCorrection.statistic, 2)
    expect(result.pValue).toBeCloseTo(d.withCorrection.pValue, 3)
  })
})

// ─── Binomial Test ──────────────────────────────────────────────────────

describe('Binomial Test — R equivalence', () => {
  const tests = [
    { name: 'test1 (7/10, p0=0.5)', d: ref.binomial.test1 },
    { name: 'test2 (3/20, p0=0.5)', d: ref.binomial.test2 },
    { name: 'test3 (15/15, p0=0.5)', d: ref.binomial.test3 },
    { name: 'test4 (0/10, p0=0.3)', d: ref.binomial.test4 },
  ]

  for (const { name, d } of tests) {
    it(`matches R binom.test — ${name}`, () => {
      const result = binomialTest(d.successes, d.trials, d.p0)

      expect(result.pValue).toBeCloseTo(d.pValue, 3)
      expect(result.ci[0]).toBeCloseTo(d.ci_lower, 2)
      expect(result.ci[1]).toBeCloseTo(d.ci_upper, 2)
    })
  }
})

// ─── Proportions Z-Test ─────────────────────────────────────────────────

describe('Proportions Z-Test — R equivalence', () => {
  it('matches R prop.test (1-sample)', () => {
    const d = ref.proportionsZ.oneSample
    const result = proportionsZTest(d.x, d.n, undefined, undefined, d.p0)

    // R gives chi-squared = z^2, we give z
    expect(result.statistic ** 2).toBeCloseTo(d.chiSq, 1)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
  })

  it('matches R prop.test (2-sample, no Yates)', () => {
    const d = ref.proportionsZ.twoSample
    const result = proportionsZTest(d.x1, d.n1, d.x2, d.n2, 0.5, 'two.sided', 0.95, false)

    expect(result.statistic ** 2).toBeCloseTo(d.chiSq, 1)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
  })

  it('matches R prop.test (2-sample, Yates correction)', () => {
    const d = ref.proportionsZ.twoSampleYates
    const result = proportionsZTest(d.x1, d.n1, d.x2, d.n2, 0.5, 'two.sided', 0.95, true)

    expect(result.statistic ** 2).toBeCloseTo(d.chiSq, 1)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
  })
})

// ─── Point-Biserial Correlation ─────────────────────────────────────────

describe('Point-Biserial Correlation — R equivalence', () => {
  it('matches R cor.test', () => {
    const d = ref.pointBiserial
    const result = pointBiserialCorrelation(d.binary, d.continuous)

    expect(result.effectSize.value).toBeCloseTo(d.r, 3)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
    expect(result.ci[0]).toBeCloseTo(d.ci_lower, 2)
    expect(result.ci[1]).toBeCloseTo(d.ci_upper, 2)
  })
})

// ─── Cramér's V ─────────────────────────────────────────────────────────

describe("Cramér's V — R equivalence", () => {
  it('matches R chisq.test for V computation', () => {
    const d = ref.cramersV
    const result = chiSquareTest(d.observed)

    expect(result.statistic).toBeCloseTo(d.chiSq, 2)
    expect(result.effectSize.value).toBeCloseTo(d.cramersV, 3)
    expect(result.pValue).toBeCloseTo(d.pValue, 3)
  })
})

// ─── Two-Way ANOVA ──────────────────────────────────────────────────────

describe('Two-Way ANOVA — R equivalence', () => {
  it('matches car::Anova Type II', () => {
    const d = ref.twoWayANOVA
    const result = twoWayANOVA(d.data.y, d.data.factorA, d.data.factorB, 2)

    const rowA = result.rows.find(r => r.source === 'A')!
    const rowB = result.rows.find(r => r.source === 'B')!
    const rowAB = result.rows.find(r => r.source === 'A:B')!

    // SS
    expect(rowA.ss).toBeCloseTo(d.typeII.ss_A, 1)
    expect(rowB.ss).toBeCloseTo(d.typeII.ss_B, 1)
    expect(rowAB.ss).toBeCloseTo(d.typeII.ss_AB, 1)
    expect(result.residual.ss).toBeCloseTo(d.typeII.ss_Residuals, 1)

    // F
    expect(rowA.F).toBeCloseTo(d.typeII.F_A, 1)
    expect(rowB.F).toBeCloseTo(d.typeII.F_B, 1)
    expect(rowAB.F).toBeCloseTo(d.typeII.F_AB, 1)

    // p-values
    expect(rowA.pValue).toBeCloseTo(d.typeII.p_A, 3)
    expect(rowB.pValue).toBeCloseTo(d.typeII.p_B, 3)
    expect(rowAB.pValue).toBeCloseTo(d.typeII.p_AB, 3)

    // df
    expect(rowA.df).toBe(d.typeII.df_A)
    expect(rowB.df).toBe(d.typeII.df_B)
    expect(rowAB.df).toBe(d.typeII.df_AB)
    expect(result.residual.df).toBe(d.typeII.df_Residuals)
  })

  it('matches car::Anova Type III', () => {
    const d = ref.twoWayANOVA
    const result = twoWayANOVA(d.data.y, d.data.factorA, d.data.factorB, 3)

    const rowA = result.rows.find(r => r.source === 'A')!
    const rowB = result.rows.find(r => r.source === 'B')!
    const rowAB = result.rows.find(r => r.source === 'A:B')!

    // SS
    expect(rowA.ss).toBeCloseTo(d.typeIII.ss_A, 1)
    expect(rowB.ss).toBeCloseTo(d.typeIII.ss_B, 1)
    expect(rowAB.ss).toBeCloseTo(d.typeIII.ss_AB, 1)

    // F
    expect(rowA.F).toBeCloseTo(d.typeIII.F_A, 1)
    expect(rowB.F).toBeCloseTo(d.typeIII.F_B, 1)
    expect(rowAB.F).toBeCloseTo(d.typeIII.F_AB, 1)

    // p-values
    expect(rowA.pValue).toBeCloseTo(d.typeIII.p_A, 3)
    expect(rowB.pValue).toBeCloseTo(d.typeIII.p_B, 3)
    expect(rowAB.pValue).toBeCloseTo(d.typeIII.p_AB, 3)
  })
})

// ─── ANCOVA ─────────────────────────────────────────────────────────────

describe('ANCOVA — R equivalence', () => {
  it('matches car::Anova Type III', () => {
    const d = ref.ancova
    const result = ancova(d.data.y, d.data.group, d.data.covariate)

    const rowFactor = result.rows.find(r => r.source === 'Factor')!
    const rowCov = result.rows.find(r => r.source === 'Covariate')!

    // SS
    expect(rowFactor.ss).toBeCloseTo(d.ss_group, 1)
    expect(rowCov.ss).toBeCloseTo(d.ss_cov, 1)
    expect(result.residual.ss).toBeCloseTo(d.ss_Residuals, 1)

    // F
    expect(rowFactor.F).toBeCloseTo(d.F_group, 1)
    expect(rowCov.F).toBeCloseTo(d.F_cov, 1)

    // p-values
    expect(rowFactor.pValue).toBeCloseTo(d.p_group, 3)
    expect(rowCov.pValue).toBeCloseTo(d.p_cov, 3)

    // df
    expect(rowFactor.df).toBe(d.df_group)
    expect(rowCov.df).toBe(d.df_cov)
    expect(result.residual.df).toBe(d.df_Residuals)

    // Adjusted means
    const adjControl = result.adjustedMeans.find(m => m.label === 'Control')!
    const adjTreatment = result.adjustedMeans.find(m => m.label === 'Treatment')!
    expect(adjControl.adjustedMean).toBeCloseTo(d.adjustedMeans.Control, 1)
    expect(adjTreatment.adjustedMean).toBeCloseTo(d.adjustedMeans.Treatment, 1)
  })
})

// ─── Quasi-Poisson ──────────────────────────────────────────────────────

describe('Quasi-Poisson — R equivalence', () => {
  it('matches R glm(family=quasipoisson)', () => {
    const d = ref.quasiPoisson
    const result = quasiPoissonRegression(
      d.data.y,
      [{ name: 'x', values: d.data.x }]
    )

    // Coefficients
    const intc = result.coefficients.find(c => c.name === '(Intercept)')!
    const xCoef = result.coefficients.find(c => c.name === 'x')!

    expect(intc.estimate).toBeCloseTo(d.coefficients.intercept.estimate, 1)
    expect(xCoef.estimate).toBeCloseTo(d.coefficients.x.estimate, 1)

    // Scaled SEs
    expect(intc.se).toBeCloseTo(d.coefficients.intercept.se, 1)
    expect(xCoef.se).toBeCloseTo(d.coefficients.x.se, 1)

    // Dispersion
    expect(result.dispersion).toBeCloseTo(d.dispersion, 1)
  })
})

// ─── Negative Binomial ──────────────────────────────────────────────────

describe('Negative Binomial — R equivalence', () => {
  it('matches R MASS::glm.nb', () => {
    const d = ref.negativeBinomial
    const result = negativeBinomialRegression(
      d.data.y,
      [{ name: 'x', values: d.data.x }]
    )

    // Coefficients (iterative — wider tolerance)
    const intc = result.coefficients.find(c => c.name === '(Intercept)')!
    const xCoef = result.coefficients.find(c => c.name === 'x')!

    expect(intc.estimate).toBeCloseTo(d.coefficients.intercept.estimate, 0)
    expect(xCoef.estimate).toBeCloseTo(d.coefficients.x.estimate, 0)

    // SEs (wider tolerance for iterative)
    expect(intc.se).toBeCloseTo(d.coefficients.intercept.se, 0)
    expect(xCoef.se).toBeCloseTo(d.coefficients.x.se, 0)

    // Theta
    expect(result.theta).toBeCloseTo(d.theta, 0)

    // AIC
    expect(result.aic).toBeCloseTo(d.aic, 0)
  })
})

// ─── Ordinal Logistic ───────────────────────────────────────────────────

describe('Ordinal Logistic — R equivalence', () => {
  it('matches R MASS::polr', () => {
    const d = ref.ordinalLogistic
    const result = ordinalLogisticRegression(
      d.data.y,
      [
        { name: 'x1', values: d.data.x1 },
        { name: 'x2', values: d.data.x2 },
      ]
    )

    // Coefficients (wider tolerance for iterative)
    const x1 = result.coefficients.find(c => c.name === 'x1')!
    const x2 = result.coefficients.find(c => c.name === 'x2')!

    expect(x1.estimate).toBeCloseTo(d.coefficients.x1.estimate, 0)
    expect(x2.estimate).toBeCloseTo(d.coefficients.x2.estimate, 0)
    expect(x1.se).toBeCloseTo(d.coefficients.x1.se, 0)
    expect(x2.se).toBeCloseTo(d.coefficients.x2.se, 0)

    // Thresholds
    const t12 = result.thresholds.find(t => t.name === '1|2')!
    const t23 = result.thresholds.find(t => t.name === '2|3')!
    const t34 = result.thresholds.find(t => t.name === '3|4')!

    expect(t12.estimate).toBeCloseTo(d.thresholds.t1_2, 0)
    expect(t23.estimate).toBeCloseTo(d.thresholds.t2_3, 0)
    expect(t34.estimate).toBeCloseTo(d.thresholds.t3_4, 0)

    // Log-likelihood and AIC
    expect(result.logLik).toBeCloseTo(d.logLik, 0)
    expect(result.aic).toBeCloseTo(d.aic, 0)
    expect(result.nCategories).toBe(d.nCategories)
  })
})

// ─── Bootstrap CI ───────────────────────────────────────────────────────

describe('Bootstrap CI — R equivalence', () => {
  it('produces correct point estimate for mean', () => {
    const d = ref.bootstrap
    const result = bootstrapCI(d.data, (arr) => {
      let s = 0
      for (const v of arr) s += v
      return s / arr.length
    }, { nBoot: 5000, seed: 42 })

    expect(result.estimate).toBeCloseTo(d.trueMean, 6)
  })

  it('produces correct point estimate for median', () => {
    const d = ref.bootstrap
    const sorted = [...d.data].sort((a, b) => a - b)
    const trueMedian = sorted.length % 2 === 0
      ? (sorted[sorted.length / 2 - 1]! + sorted[sorted.length / 2]!) / 2
      : sorted[Math.floor(sorted.length / 2)]!

    const result = bootstrapCI(d.data, (arr) => {
      const s = [...arr].sort((a, b) => a - b)
      const n = s.length
      return n % 2 === 0 ? (s[n / 2 - 1]! + s[n / 2]!) / 2 : s[Math.floor(n / 2)]!
    }, { nBoot: 5000, seed: 42 })

    expect(result.estimate).toBeCloseTo(trueMedian, 6)
    // CI should contain the true median
    expect(result.ci[0]).toBeLessThan(trueMedian)
    expect(result.ci[1]).toBeGreaterThan(trueMedian)
  })

  it('BCa produces valid CI for mean', () => {
    const d = ref.bootstrap
    const result = bootstrapCI(d.data, (arr) => {
      let s = 0
      for (const v of arr) s += v
      return s / arr.length
    }, { nBoot: 5000, seed: 42, method: 'bca' })

    expect(result.estimate).toBeCloseTo(d.trueMean, 6)
    expect(result.ci[0]).toBeLessThan(d.trueMean)
    expect(result.ci[1]).toBeGreaterThan(d.trueMean)
  })
})
