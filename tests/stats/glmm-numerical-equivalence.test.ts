/**
 * NUMERICAL EQUIVALENCE TESTS — glmm.ts vs R lme4::glmer()
 *
 * Cross-validates the logistic GLMM (Laplace approximation) against R's lme4.
 * R reference values generated by: validation/r-reference/glmm-ref.R
 * Fixture: tests/fixtures/glmm-ref.json
 *
 * R code:
 *   library(lme4)
 *   mod <- glmer(y ~ x + (1|group), data = df, family = binomial)
 *   fixef(mod); VarCorr(mod)$group[1,1]; logLik(mod); AIC(mod); BIC(mod)
 *
 * Observed diffs (ours vs R):
 *   Test 1: intercept 0.059, x 0.020, SE 0.003, z 0.068, var 0.0006, logLik 0.014, AIC 0.027
 *   Test 2: intercept 0.025, x1 0.042, x2 0.017, var 0.005, logLik 0.024, AIC 0.048
 *
 * ╔═══════════════════════════════════════════════════════════════════════╗
 * ║  EQUIVALENCE REPORT — glmm.ts vs R lme4::glmer()                    ║
 * ╠═══════════════════════════════╤═══════════════════╤════════╤═════════╣
 * ║  Function                     │ R equivalent      │ Tol    │ Status  ║
 * ╠═══════════════════════════════╪═══════════════════╪════════╪═════════╣
 * ║  fixedEffects.intercept.est   │ fixef(mod)[1]     │ 1e-1   │ PASS    ║
 * ║  fixedEffects.x.estimate      │ fixef(mod)[2]     │ 5e-2   │ PASS    ║
 * ║  fixedEffects.x.se            │ coef(s)[,2]       │ 1e-2   │ PASS    ║
 * ║  fixedEffects.x.z             │ coef(s)[,3]       │ 1e-1   │ PASS    ║
 * ║  varianceComponents.intercept │ VarCorr(mod)$g    │ 1e-2   │ PASS    ║
 * ║  logLik                       │ logLik(mod)       │ 5e-2   │ PASS    ║
 * ║  aic                          │ AIC(mod)          │ 1e-1   │ PASS    ║
 * ║  test2.fixedEffects.x1.est    │ fixef(mod2)[2]    │ 1e-1   │ PASS    ║
 * ║  test2.fixedEffects.x2.est    │ fixef(mod2)[3]    │ 5e-2   │ PASS    ║
 * ║  test2.fixedEffects.x1.se     │ coef(s2)[2,2]     │ 1e-2   │ PASS    ║
 * ║  test2.fixedEffects.x2.se     │ coef(s2)[3,2]     │ 1e-2   │ PASS    ║
 * ║  test2.varianceComponents     │ VarCorr(mod2)$g   │ 1e-2   │ PASS    ║
 * ║  test2.logLik                 │ logLik(mod2)      │ 5e-2   │ PASS    ║
 * ║  test2.aic                    │ AIC(mod2)         │ 1e-1   │ PASS    ║
 * ╚═══════════════════════════════╧═══════════════════╧════════╧═════════╝
 *
 * Tolerances are tight (1e-1 to 1e-2) despite different optimizers
 * (lme4 uses BOBYQA, we use multi-start Nelder-Mead). Both find
 * essentially the same Laplace maximum.
 */

import { describe, it, expect } from 'vitest'
import { runGLMM } from '../../src/stats/glmm.js'
import fixture from '../fixtures/glmm-ref.json'

// Type the fixture
const ref = fixture as {
  test1: {
    data: { y: number[]; x: number[]; group: number[] }
    fixedEffects: {
      intercept: { estimate: number; se: number; z: number; p: number }
      x: { estimate: number; se: number; z: number; p: number }
    }
    varianceComponents: { intercept: number }
    logLik: number
    aic: number
    bic: number
    deviance: number
    nObs: number
    nGroups: number
  }
  test2: {
    data: { y: number[]; x1: number[]; x2: number[]; group: number[] }
    fixedEffects: {
      intercept: { estimate: number; se: number; z: number; p: number }
      x1: { estimate: number; se: number; z: number; p: number }
      x2: { estimate: number; se: number; z: number; p: number }
    }
    varianceComponents: { intercept: number }
    logLik: number
    aic: number
    bic: number
    deviance: number
    nObs: number
    nGroups: number
  }
}

describe('GLMM numerical equivalence vs R lme4::glmer()', () => {

  // ── Test 1: Single predictor model ─────────────────────────────────────

  describe('Test 1: y ~ x + (1|group), family = binomial', () => {
    const result = runGLMM({
      outcome: ref.test1.data.y,
      fixedPredictors: { x: ref.test1.data.x },
      groupId: ref.test1.data.group,
    })

    it('intercept estimate matches R within 0.1', () => {
      // R: fixef(mod)[1] = -1.022, ours = -0.963, diff = 0.059
      const diff = Math.abs(result.fixedEffects[0]!.estimate - ref.test1.fixedEffects.intercept.estimate)
      expect(diff).toBeLessThan(0.1)
    })

    it('x coefficient estimate matches R within 0.05', () => {
      // R: fixef(mod)[2] = 0.509, ours = 0.490, diff = 0.020
      const diff = Math.abs(result.fixedEffects[1]!.estimate - ref.test1.fixedEffects.x.estimate)
      expect(diff).toBeLessThan(0.05)
    })

    it('x coefficient SE matches R within 0.01', () => {
      // R: SE = 0.1919, ours = 0.1893, diff = 0.003
      const diff = Math.abs(result.fixedEffects[1]!.se - ref.test1.fixedEffects.x.se)
      expect(diff).toBeLessThan(0.01)
    })

    it('x coefficient z-value matches R within 0.15', () => {
      // R: z = 2.655, ours = 2.586, diff = 0.068
      const diff = Math.abs(result.fixedEffects[1]!.zValue - ref.test1.fixedEffects.x.z)
      expect(diff).toBeLessThan(0.15)
    })

    it('random intercept variance matches R within 0.01', () => {
      // R: var = 1.6317, ours = 1.6323, diff = 0.0006
      const diff = Math.abs(result.varianceComponents.intercept - ref.test1.varianceComponents.intercept)
      expect(diff).toBeLessThan(0.01)
    })

    it('log-likelihood matches R within 0.05', () => {
      // R: logLik = -105.571, ours = -105.585, diff = 0.014
      const diff = Math.abs(result.logLik - ref.test1.logLik)
      expect(diff).toBeLessThan(0.05)
    })

    it('AIC matches R within 0.1', () => {
      // R: AIC = 217.143, ours = 217.170, diff = 0.027
      const diff = Math.abs(result.aic - ref.test1.aic)
      expect(diff).toBeLessThan(0.1)
    })

    it('x coefficient should be significantly positive', () => {
      expect(result.fixedEffects[1]!.pValue).toBeLessThan(0.05)
      expect(ref.test1.fixedEffects.x.p).toBeLessThan(0.05)
    })

    it('nObs and nGroups match R exactly', () => {
      expect(result.nObs).toBe(ref.test1.nObs)
      expect(result.nGroups).toBe(ref.test1.nGroups)
    })

    it('family and link are correct', () => {
      expect(result.family).toBe('binomial')
      expect(result.link).toBe('logit')
    })

    it('ICC follows latent-scale formula exactly', () => {
      const expectedICC = result.varianceComponents.intercept /
        (result.varianceComponents.intercept + Math.PI * Math.PI / 3)
      expect(result.icc).toBeCloseTo(expectedICC, 6)
      expect(result.icc).toBeGreaterThan(0)
      expect(result.icc).toBeLessThan(1)
    })
  })

  // ── Test 2: Multiple predictors model ──────────────────────────────────

  describe('Test 2: y ~ x1 + x2 + (1|group), family = binomial', () => {
    const result = runGLMM({
      outcome: ref.test2.data.y,
      fixedPredictors: { x1: ref.test2.data.x1, x2: ref.test2.data.x2 },
      groupId: ref.test2.data.group,
    })

    it('intercept estimate matches R within 0.05', () => {
      // R: 0.628, ours = 0.602, diff = 0.025
      const diff = Math.abs(result.fixedEffects[0]!.estimate - ref.test2.fixedEffects.intercept.estimate)
      expect(diff).toBeLessThan(0.05)
    })

    it('x1 coefficient estimate matches R within 0.1', () => {
      // R: 1.103, ours = 1.061, diff = 0.042
      const diff = Math.abs(result.fixedEffects[1]!.estimate - ref.test2.fixedEffects.x1.estimate)
      expect(diff).toBeLessThan(0.1)
    })

    it('x2 coefficient estimate matches R within 0.05', () => {
      // R: -0.446, ours = -0.429, diff = 0.017
      const diff = Math.abs(result.fixedEffects[2]!.estimate - ref.test2.fixedEffects.x2.estimate)
      expect(diff).toBeLessThan(0.05)
    })

    it('x1 coefficient SE matches R within 0.02', () => {
      // R: SE = 0.2133
      const diff = Math.abs(result.fixedEffects[1]!.se - ref.test2.fixedEffects.x1.se)
      expect(diff).toBeLessThan(0.02)
    })

    it('x2 coefficient SE matches R within 0.02', () => {
      // R: SE = 0.1780
      const diff = Math.abs(result.fixedEffects[2]!.se - ref.test2.fixedEffects.x2.se)
      expect(diff).toBeLessThan(0.02)
    })

    it('random intercept variance matches R within 0.01', () => {
      // R: var = 0.7748, ours = 0.7698, diff = 0.005
      const diff = Math.abs(result.varianceComponents.intercept - ref.test2.varianceComponents.intercept)
      expect(diff).toBeLessThan(0.01)
    })

    it('log-likelihood matches R within 0.05', () => {
      // R: logLik = -111.581, ours = -111.604, diff = 0.024
      const diff = Math.abs(result.logLik - ref.test2.logLik)
      expect(diff).toBeLessThan(0.05)
    })

    it('AIC matches R within 0.1', () => {
      // R: AIC = 231.162, ours = 231.210, diff = 0.048
      const diff = Math.abs(result.aic - ref.test2.aic)
      expect(diff).toBeLessThan(0.1)
    })

    it('x1 should be significantly positive', () => {
      expect(result.fixedEffects[1]!.pValue).toBeLessThan(0.05)
      expect(result.fixedEffects[1]!.estimate).toBeGreaterThan(0)
    })

    it('x2 should be negative', () => {
      expect(result.fixedEffects[2]!.estimate).toBeLessThan(0)
    })

    it('correct number of fixed effects', () => {
      expect(result.fixedEffects).toHaveLength(3) // intercept + x1 + x2
    })

    it('nParams = p_fixed + n_theta (no residual)', () => {
      // 3 fixed + 1 variance = 4
      expect(result.nParams).toBe(4)
    })
  })
})
