{
  "version": 3,
  "sources": ["../src/core/matrix.ts", "../src/core/prng.ts"],
  "sourcesContent": ["/**\n * Matrix class for Carm.\n * Implements multiply, transpose, inverse (via Cholesky or LU), log-determinant, and SVD.\n * Pure computation \u2014 no DOM, no D3, no side effects.\n */\n\nexport class Matrix {\n  readonly rows: number\n  readonly cols: number\n  private readonly _data: readonly number[]  // row-major flat array\n\n  constructor(rows: number, cols: number, data?: readonly number[]) {\n    this.rows = rows\n    this.cols = cols\n    this._data = data ?? new Array<number>(rows * cols).fill(0)\n    if (this._data.length !== rows * cols) {\n      throw new Error(`Matrix data length ${this._data.length} does not match ${rows}\u00D7${cols}`)\n    }\n  }\n\n  /** Build from 2-D array (row-major). */\n  static fromArray(arr: readonly (readonly number[])[]): Matrix {\n    const rows = arr.length\n    if (rows === 0) throw new Error('Matrix cannot have 0 rows')\n    const cols = arr[0]!.length\n    const data: number[] = []\n    for (const row of arr) {\n      if (row.length !== cols) throw new Error('All rows must have equal length')\n      for (const v of row) data.push(v)\n    }\n    return new Matrix(rows, cols, data)\n  }\n\n  /** Identity matrix of size n. */\n  static identity(n: number): Matrix {\n    const data = new Array<number>(n * n).fill(0)\n    for (let i = 0; i < n; i++) data[i * n + i] = 1\n    return new Matrix(n, n, data)\n  }\n\n  /** Zero matrix. */\n  static zeros(rows: number, cols: number): Matrix {\n    return new Matrix(rows, cols, new Array<number>(rows * cols).fill(0))\n  }\n\n  /** Get element at (i, j) \u2014 0-indexed. */\n  get(i: number, j: number): number {\n    const v = this._data[i * this.cols + j]\n    if (v === undefined) throw new Error(`Index (${i},${j}) out of bounds for ${this.rows}\u00D7${this.cols}`)\n    return v\n  }\n\n  /** Return 2-D array representation. */\n  toArray(): number[][] {\n    return Array.from({ length: this.rows }, (_, i) =>\n      Array.from({ length: this.cols }, (_, j) => this.get(i, j))\n    )\n  }\n\n  /** Return flat row-major copy. */\n  toFlat(): number[] {\n    return [...this._data]\n  }\n\n  /** Matrix transpose. */\n  transpose(): Matrix {\n    const data: number[] = new Array(this.rows * this.cols)\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.cols; j++) {\n        data[j * this.rows + i] = this.get(i, j)\n      }\n    }\n    return new Matrix(this.cols, this.rows, data)\n  }\n\n  /** Matrix multiplication: this \u00D7 other. */\n  multiply(other: Matrix): Matrix {\n    if (this.cols !== other.rows) {\n      throw new Error(`Dimension mismatch: ${this.rows}\u00D7${this.cols} \u00D7 ${other.rows}\u00D7${other.cols}`)\n    }\n    const data: number[] = new Array(this.rows * other.cols).fill(0)\n    for (let i = 0; i < this.rows; i++) {\n      for (let k = 0; k < this.cols; k++) {\n        const aik = this.get(i, k)\n        for (let j = 0; j < other.cols; j++) {\n          data[i * other.cols + j]! += aik * other.get(k, j)\n        }\n      }\n    }\n    return new Matrix(this.rows, other.cols, data)\n  }\n\n  /** Scalar multiplication. */\n  scale(s: number): Matrix {\n    return new Matrix(this.rows, this.cols, this._data.map(v => v * s))\n  }\n\n  /** Element-wise add. */\n  add(other: Matrix): Matrix {\n    if (this.rows !== other.rows || this.cols !== other.cols) {\n      throw new Error('Matrix dimensions must match for addition')\n    }\n    return new Matrix(this.rows, this.cols, this._data.map((v, i) => v + (other._data[i] ?? 0)))\n  }\n\n  /** Element-wise subtract. */\n  subtract(other: Matrix): Matrix {\n    if (this.rows !== other.rows || this.cols !== other.cols) {\n      throw new Error('Matrix dimensions must match for subtraction')\n    }\n    return new Matrix(this.rows, this.cols, this._data.map((v, i) => v - (other._data[i] ?? 0)))\n  }\n\n  /**\n   * Cholesky decomposition for symmetric positive-definite matrices.\n   * Returns lower-triangular L such that this = L * L^T.\n   * Throws if matrix is not SPD.\n   */\n  cholesky(): Matrix {\n    if (this.rows !== this.cols) throw new Error('Cholesky requires square matrix')\n    const n = this.rows\n    const L: number[] = new Array(n * n).fill(0)\n\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j <= i; j++) {\n        let sum = this.get(i, j)\n        for (let k = 0; k < j; k++) {\n          sum -= (L[i * n + k] ?? 0) * (L[j * n + k] ?? 0)\n        }\n        if (i === j) {\n          if (sum <= 0) throw new Error(`Matrix is not positive definite (diagonal became ${sum} at position ${i})`)\n          L[i * n + j] = Math.sqrt(sum)\n        } else {\n          const diag = L[j * n + j]\n          if (!diag || diag === 0) throw new Error('Zero diagonal in Cholesky')\n          L[i * n + j] = sum / diag\n        }\n      }\n    }\n    return new Matrix(n, n, L)\n  }\n\n  /**\n   * Log-determinant via Cholesky: log|A| = 2 * \u03A3 log(L_ii).\n   * Only valid for symmetric positive-definite matrices.\n   */\n  logDet(): number {\n    const L = this.cholesky()\n    let logdet = 0\n    for (let i = 0; i < this.rows; i++) {\n      const diag = L.get(i, i)\n      if (diag <= 0) throw new Error('Non-positive diagonal in Cholesky')\n      logdet += Math.log(diag)\n    }\n    return 2 * logdet\n  }\n\n  /**\n   * Inverse via LU decomposition with partial pivoting.\n   * Works for any non-singular square matrix.\n   * Formula: Doolittle LU, then forward/back substitution for each column of I.\n   */\n  inverse(): Matrix {\n    if (this.rows !== this.cols) throw new Error('Inverse requires square matrix')\n    const n = this.rows\n    // Build augmented matrix [A | I]\n    const aug: number[] = new Array(n * 2 * n)\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        aug[i * 2 * n + j] = this.get(i, j)\n        aug[i * 2 * n + n + j] = i === j ? 1 : 0\n      }\n    }\n\n    // Gaussian elimination with partial pivoting\n    for (let col = 0; col < n; col++) {\n      // Find pivot\n      let maxRow = col\n      let maxVal = Math.abs(aug[col * 2 * n + col] ?? 0)\n      for (let row = col + 1; row < n; row++) {\n        const v = Math.abs(aug[row * 2 * n + col] ?? 0)\n        if (v > maxVal) { maxVal = v; maxRow = row }\n      }\n      if (maxVal < 1e-12) throw new Error('Matrix is singular or near-singular')\n\n      // Swap rows\n      if (maxRow !== col) {\n        for (let j = 0; j < 2 * n; j++) {\n          const tmp = aug[col * 2 * n + j] ?? 0\n          aug[col * 2 * n + j] = aug[maxRow * 2 * n + j] ?? 0\n          aug[maxRow * 2 * n + j] = tmp\n        }\n      }\n\n      const pivot = aug[col * 2 * n + col] ?? 0\n      // Eliminate below\n      for (let row = 0; row < n; row++) {\n        if (row === col) continue\n        const factor = (aug[row * 2 * n + col] ?? 0) / pivot\n        for (let j = 0; j < 2 * n; j++) {\n          aug[row * 2 * n + j]! -= factor * (aug[col * 2 * n + j] ?? 0)\n        }\n      }\n      // Scale pivot row\n      for (let j = 0; j < 2 * n; j++) {\n        aug[col * 2 * n + j]! /= pivot\n      }\n    }\n\n    // Extract right half (inverse)\n    const inv: number[] = new Array(n * n)\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        inv[i * n + j] = aug[i * 2 * n + n + j] ?? 0\n      }\n    }\n    return new Matrix(n, n, inv)\n  }\n\n  /**\n   * Singular Value Decomposition: A = U \u00B7 S \u00B7 V^T\n   * Returns { U, S (diagonal values), V }.\n   * Algorithm: Golub-Reinsch (one-sided Jacobi for small matrices).\n   * Reference: Golub & Van Loan, \"Matrix Computations\", 4th ed., Algorithm 8.6.2\n   */\n  svd(): { U: Matrix; S: number[]; V: Matrix } {\n    // Use Jacobi one-sided SVD\n    const m = this.rows\n    const n = this.cols\n    // Work on a copy of A as column matrix V^T = I\n    const a = this.toArray()\n    const v: number[][] = Array.from({ length: n }, (_, i) =>\n      Array.from({ length: n }, (_, j) => (i === j ? 1 : 0))\n    )\n\n    const MAX_ITER = 200 * n * n\n    for (let iter = 0; iter < MAX_ITER; iter++) {\n      let converged = true\n      for (let p = 0; p < n - 1; p++) {\n        for (let q = p + 1; q < n; q++) {\n          // Compute alpha, beta, gamma for Jacobi rotation\n          let alpha = 0, beta = 0, gamma = 0\n          for (let i = 0; i < m; i++) {\n            alpha += (a[i]![p] ?? 0) ** 2\n            beta  += (a[i]![q] ?? 0) ** 2\n            gamma += (a[i]![p] ?? 0) * (a[i]![q] ?? 0)\n          }\n          if (Math.abs(gamma) < 1e-15 * Math.sqrt(alpha * beta)) continue\n          converged = false\n          const zeta = (beta - alpha) / (2 * gamma)\n          const t = Math.sign(zeta) / (Math.abs(zeta) + Math.sqrt(1 + zeta * zeta))\n          const c = 1 / Math.sqrt(1 + t * t)\n          const s = t * c\n\n          // Update columns p and q of a\n          for (let i = 0; i < m; i++) {\n            const ap = a[i]![p] ?? 0\n            const aq = a[i]![q] ?? 0\n            a[i]![p] = c * ap + s * aq\n            a[i]![q] = -s * ap + c * aq\n          }\n          // Update V\n          for (let i = 0; i < n; i++) {\n            const vp = v[i]![p] ?? 0\n            const vq = v[i]![q] ?? 0\n            v[i]![p] = c * vp + s * vq\n            v[i]![q] = -s * vp + c * vq\n          }\n        }\n      }\n      if (converged) break\n    }\n\n    // Compute singular values and normalize columns of a \u2192 U\n    const singularValues = Array.from({ length: n }, (_, j) => {\n      let sum = 0\n      for (let i = 0; i < m; i++) sum += (a[i]![j] ?? 0) ** 2\n      return Math.sqrt(sum)\n    })\n\n    // Build U (m\u00D7n), normalize each column\n    const uData: number[][] = Array.from({ length: m }, () => new Array<number>(n).fill(0))\n    for (let j = 0; j < n; j++) {\n      const sv = singularValues[j] ?? 0\n      for (let i = 0; i < m; i++) {\n        uData[i]![j] = sv > 1e-15 ? (a[i]![j] ?? 0) / sv : 0\n      }\n    }\n\n    // Sort by descending singular value, truncate to k = min(m, n)\n    const order = singularValues.map((_, i) => i).sort((a, b) => (singularValues[b] ?? 0) - (singularValues[a] ?? 0))\n    const k = Math.min(m, n)\n    const S = order.slice(0, k).map(i => singularValues[i] ?? 0)\n    const Uarr: number[][] = Array.from({ length: m }, (_, i) => order.slice(0, k).map(j => uData[i]![j] ?? 0))\n    const Varr: number[][] = Array.from({ length: n }, (_, i) => order.slice(0, k).map(j => v[i]![j] ?? 0))\n\n    return {\n      U: Matrix.fromArray(Uarr),\n      S,\n      V: Matrix.fromArray(Varr),\n    }\n  }\n\n  /**\n   * Pseudo-inverse via SVD: A+ = V \u00B7 S^{-1} \u00B7 U^T\n   */\n  pseudoInverse(tol = 1e-10): Matrix {\n    const { U, S, V } = this.svd()\n    const maxS = Math.max(...S)\n    const threshold = tol * maxS\n    const SInv = S.map(s => (s > threshold ? 1 / s : 0))\n\n    // V * diag(SInv)\n    const VSInv = Matrix.fromArray(\n      Array.from({ length: V.rows }, (_, i) =>\n        Array.from({ length: V.cols }, (_, j) => V.get(i, j) * (SInv[j] ?? 0))\n      )\n    )\n    return VSInv.multiply(U.transpose())\n  }\n\n  /** Trace (sum of diagonal elements). */\n  trace(): number {\n    const n = Math.min(this.rows, this.cols)\n    let t = 0\n    for (let i = 0; i < n; i++) t += this.get(i, i)\n    return t\n  }\n\n  /** Extract diagonal as array. */\n  diagonal(): number[] {\n    const n = Math.min(this.rows, this.cols)\n    return Array.from({ length: n }, (_, i) => this.get(i, i))\n  }\n\n  /** Column vector as Matrix from array. */\n  static colVec(data: readonly number[]): Matrix {\n    return new Matrix(data.length, 1, [...data])\n  }\n\n  /** Row vector as Matrix from array. */\n  static rowVec(data: readonly number[]): Matrix {\n    return new Matrix(1, data.length, [...data])\n  }\n\n  /**\n   * Eigendecomposition for symmetric matrices via Jacobi iterations.\n   * Returns { values, vectors } where vectors are columns of the eigenvector matrix.\n   * Reference: Golub & Van Loan, Algorithm 8.4.1\n   */\n  eigen(): { values: number[]; vectors: Matrix } {\n    if (this.rows !== this.cols) throw new Error('eigen() requires square matrix')\n    const n = this.rows\n    const a = this.toArray()\n    const q: number[][] = Array.from({ length: n }, (_, i) =>\n      Array.from({ length: n }, (_, j) => (i === j ? 1 : 0))\n    )\n\n    for (let iter = 0; iter < 100 * n * n; iter++) {\n      // Find largest off-diagonal element\n      let p = 0, r = 1\n      let maxVal = Math.abs(a[0]![1] ?? 0)\n      for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n          if (Math.abs(a[i]![j] ?? 0) > maxVal) {\n            maxVal = Math.abs(a[i]![j] ?? 0)\n            p = i; r = j\n          }\n        }\n      }\n      if (maxVal < 1e-12) break\n\n      const app = a[p]![p] ?? 0, arr = a[r]![r] ?? 0, apr = a[p]![r] ?? 0\n      const theta = 0.5 * Math.atan2(2 * apr, app - arr)\n      const c = Math.cos(theta), s = Math.sin(theta)\n\n      // Update a\n      const newApp = c * c * app + 2 * s * c * apr + s * s * arr\n      const newArr = s * s * app - 2 * s * c * apr + c * c * arr\n      a[p]![p] = newApp; a[r]![r] = newArr; a[p]![r] = 0; a[r]![p] = 0\n\n      for (let i = 0; i < n; i++) {\n        if (i === p || i === r) continue\n        const aip = a[i]![p] ?? 0, air = a[i]![r] ?? 0\n        a[i]![p] = c * aip + s * air\n        a[p]![i] = a[i]![p]!\n        a[i]![r] = -s * aip + c * air\n        a[r]![i] = a[i]![r]!\n      }\n\n      // Update eigenvectors\n      for (let i = 0; i < n; i++) {\n        const qip = q[i]![p] ?? 0, qir = q[i]![r] ?? 0\n        q[i]![p] = c * qip + s * qir\n        q[i]![r] = -s * qip + c * qir\n      }\n    }\n\n    const values = Array.from({ length: n }, (_, i) => a[i]![i] ?? 0)\n    // Sort descending\n    const order = values.map((_, i) => i).sort((a, b) => values[b]! - values[a]!)\n    return {\n      values: order.map(i => values[i]!),\n      vectors: Matrix.fromArray(Array.from({ length: n }, (_, i) => order.map(j => q[i]![j] ?? 0))),\n    }\n  }\n}\n\n/** Solve linear system A\u00B7x = b using the (already computed) inverse.  */\nexport function solveLinear(A: Matrix, b: readonly number[]): number[] {\n  const inv = A.inverse()\n  const x = inv.multiply(Matrix.colVec(b))\n  return Array.from({ length: b.length }, (_, i) => x.get(i, 0))\n}\n", "/**\n * Deterministic PRNG (splitmix32).\n * Shared across clustering, factor-analysis, bootstrap, and any stochastic module.\n * Default seed: 42. Every stochastic function accepts `seed?` in options.\n */\n\nexport class PRNG {\n  private state: number\n  constructor(seed: number) { this.state = seed >>> 0 }\n  next(): number {\n    this.state = (this.state + 0x9E3779B9) | 0\n    let t = this.state ^ (this.state >>> 16)\n    t = Math.imul(t, 0x21F0AAAD)\n    t = t ^ (t >>> 15)\n    t = Math.imul(t, 0x735A2D97)\n    t = t ^ (t >>> 15)\n    return (t >>> 0) / 4294967296\n  }\n}\n"],
  "mappings": "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",
  "names": ["_", "a"]
}
