#!/usr/bin/env npx tsx
/**
 * Cross-validate Carm quartimax and target rotation against R GPArotation.
 *
 * Quartimax: GPArotation::GPForth(L, method="quartimax")
 * Target:    GPArotation::targetQ(L, Target=T)
 *
 * R reference generated by:
 *   Rscript validation/r-reference/fa-quartimax-target-ref.R
 */
import { readFileSync, existsSync } from 'fs'
import { runEFA } from 'carm'

// Load synthetic datasets (same as geomin crossval)
const dataPath = existsSync('validation/data/fa-crossval-data.json')
  ? 'validation/data/fa-crossval-data.json'
  : 'tmp/fa-crossval-data.json'

const datasets = JSON.parse(
  readFileSync(dataPath, 'utf-8')
).datasets as Array<{
  id: number
  params: { n: number; k: number }
  data: number[][]
  variableNames: string[]
}>

// ── Permutation + sign matching ─────────────────────────────────────────────

function permutations(n: number): number[][] {
  if (n === 1) return [[0]]
  const result: number[][] = []
  const sub = permutations(n - 1)
  for (let i = 0; i < n; i++) {
    for (const perm of sub) {
      result.push([i, ...perm.map(x => x >= i ? x + 1 : x)])
    }
  }
  return result
}

function bestMAE(cLoad: number[][], rLoad: number[][], p: number, k: number): {
  mae: number; perm: number[]; signs: number[]
} {
  let bestMae = Infinity
  let bestPerm: number[] = []
  let bestSigns: number[] = []

  for (const perm of permutations(k)) {
    for (let signMask = 0; signMask < (1 << k); signMask++) {
      const signs = Array.from({ length: k }, (_, j) =>
        (signMask & (1 << j)) ? -1 : 1
      )
      let sumAE = 0
      for (let i = 0; i < p; i++) {
        for (let j = 0; j < k; j++) {
          sumAE += Math.abs(
            cLoad[i]![perm[j]!]! * signs[j]! - rLoad[i]![j]!
          )
        }
      }
      const mae = sumAE / (p * k)
      if (mae < bestMae) {
        bestMae = mae
        bestPerm = perm
        bestSigns = signs
      }
    }
  }
  return { mae: bestMae, perm: bestPerm, signs: bestSigns }
}

// ── Quartimax cross-validation ──────────────────────────────────────────────

function runQuartimaxTests(): { passed: number; failed: number } {
  const refPath = 'validation/data/fa-quartimax-ref.json'
  if (!existsSync(refPath)) {
    console.log('  Skipping quartimax: reference file not found')
    return { passed: 0, failed: 0 }
  }

  const rRef = JSON.parse(
    readFileSync(refPath, 'utf-8')
  ) as Array<{
    id: number; n: number; p: number; k: number
    loadings: number[][]
    T_matrix: number[][]
    criterion: number
    converged: boolean
  }>

  let passed = 0, failed = 0

  for (const ref of rRef) {
    const ds = datasets.find(d => d.id === ref.id)
    if (!ds) { console.log(`  [${ref.id}] dataset not found`); failed++; continue }

    try {
      const result = runEFA(ds.data, {
        nFactors: ref.k,
        extraction: 'ml',
        rotation: 'quartimax',
        randomStarts: 10,
        seed: 42,
        variableNames: ds.variableNames
      })

      const { mae } = bestMAE(result.loadings, ref.loadings, ref.p, ref.k)

      // Verify Phi = I (orthogonal)
      let phiMaxOff = 0
      for (let i = 0; i < ref.k; i++) {
        for (let j = 0; j < ref.k; j++) {
          if (i !== j) phiMaxOff = Math.max(phiMaxOff, Math.abs(result.factorCorrelations[i]![j]!))
        }
      }

      const loadingOk = mae < 0.01
      const phiOk = phiMaxOff < 1e-10

      if (loadingOk && phiOk) {
        passed++
        process.stdout.write(`[${String(ref.id).padStart(3)}] n=${ref.n} p=${ref.p} k=${ref.k} \x1b[32m✓\x1b[0m loadMAE=${mae.toFixed(4)}\n`)
      } else {
        failed++
        process.stdout.write(`[${String(ref.id).padStart(3)}] n=${ref.n} p=${ref.p} k=${ref.k} \x1b[31m✗\x1b[0m loadMAE=${mae.toFixed(4)} phiMaxOff=${phiMaxOff.toFixed(6)}\n`)
      }
    } catch (e) {
      failed++
      console.log(`[${String(ref.id).padStart(3)}] ERROR: ${(e as Error).message}`)
    }
  }

  return { passed, failed }
}

// ── Target rotation cross-validation ────────────────────────────────────────

function runTargetTests(): { passed: number; failed: number } {
  const refPath = 'validation/data/fa-target-ref.json'
  if (!existsSync(refPath)) {
    console.log('  Skipping target: reference file not found')
    return { passed: 0, failed: 0 }
  }

  const rRef = JSON.parse(
    readFileSync(refPath, 'utf-8')
  ) as Array<{
    id: number; n: number; p: number; k: number
    target: number[][]
    unrotated: number[][]
    loadings: number[][]
    phi: number[][]
    criterion: number
    converged: boolean
  }>

  let passed = 0, failed = 0

  for (const ref of rRef) {
    const ds = datasets.find(d => d.id === ref.id)
    if (!ds) { console.log(`  [${ref.id}] dataset not found`); failed++; continue }

    try {
      // Target rotation is NOT sign-invariant: the target was generated from
      // R's ML extraction, which may have different column signs than Carm's.
      // Align the target's sign convention with Carm's unrotated loadings.
      const noRot = runEFA(ds.data, {
        nFactors: ref.k, extraction: 'ml', rotation: 'none', seed: 42
      })

      const signFlips: number[] = []
      for (let j = 0; j < ref.k; j++) {
        let rSum = 0, cSum = 0
        for (let i = 0; i < ref.p; i++) {
          rSum += ref.unrotated[i]![j]!
          cSum += noRot.loadings[i]![j]!
        }
        signFlips.push(Math.sign(rSum) === Math.sign(cSum) ? 1 : -1)
      }

      const alignedTarget = ref.target.map((row: number[]) =>
        row.map((v: number, j: number) => v * signFlips[j]!)
      )

      const result = runEFA(ds.data, {
        nFactors: ref.k,
        extraction: 'ml',
        rotation: 'target',
        targetMatrix: alignedTarget,
        randomStarts: 10,
        seed: 42,
        variableNames: ds.variableNames
      })

      const { mae } = bestMAE(result.loadings, ref.loadings, ref.p, ref.k)

      if (mae < 0.01) {
        passed++
        process.stdout.write(`[${String(ref.id).padStart(3)}] n=${ref.n} p=${ref.p} k=${ref.k} \x1b[32m✓\x1b[0m loadMAE=${mae.toFixed(4)}\n`)
      } else {
        failed++
        process.stdout.write(`[${String(ref.id).padStart(3)}] n=${ref.n} p=${ref.p} k=${ref.k} \x1b[31m✗\x1b[0m loadMAE=${mae.toFixed(4)}\n`)
      }
    } catch (e) {
      failed++
      console.log(`[${String(ref.id).padStart(3)}] ERROR: ${(e as Error).message}`)
    }
  }

  return { passed, failed }
}

// ── Main ────────────────────────────────────────────────────────────────────

console.log('=== Quartimax rotation cross-validation ===\n')
const qrt = runQuartimaxTests()
console.log(`  Result: ${qrt.passed} passed, ${qrt.failed} failed\n`)

console.log('=== Target rotation cross-validation ===\n')
const tgt = runTargetTests()
console.log(`  Result: ${tgt.passed} passed, ${tgt.failed} failed\n`)

const totalPassed = qrt.passed + tgt.passed
const totalFailed = qrt.failed + tgt.failed
console.log(`=== TOTAL: ${totalPassed} passed, ${totalFailed} failed ===`)

if (totalFailed > 0) process.exit(1)
